<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>Simple Infinite Terrain - Chunk Debug</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto}
  #ui{position:fixed;left:8px;top:8px;z-index:10;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px}
  canvas{display:block;width:100vw;height:100vh;background:#222}
  .hint{opacity:0.8;font-size:13px}
</style>
</head>
<body>
<div id="ui">
  <div><strong>Controls</strong></div>
  <div class="hint">WASD / ←↑→↓ : move — Tab : toggle overview — +/- : zoom</div>
  <div class="hint" id="info"></div>
</div>
<canvas id="c"></canvas>

<script>
// ========== CONFIG ==========
const CHUNK_SIZE_PX = 256;      // ukuran chunk dalam pixel (lebar & tinggi)
const RENDER_RADIUS = 2;         // radius (chebyshev) chunk yang dirender di sekitar active chunk
const PLAYER_SPEED = 250;        // px/second
const SEED = 1337;               // seed untuk deterministic generation
// ============================

// canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize() {
  canvas.width = innerWidth * devicePixelRatio;
  canvas.height = innerHeight * devicePixelRatio;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
addEventListener('resize', resize);
resize();

// simple seeded hash -> deterministic value [0,1)
function seededValue(x, y, seed=SEED) {
  // 32-bit mix (fast, deterministic)
  let n = x * 374761393 + y * 668265263 + seed * 982451653;
  n = (n ^ (n >>> 13)) >>> 0;
  n = (n * 1274126177) >>> 0;
  return (n >>> 0) / 0xFFFFFFFF;
}

// chunk key helper
function key(cx, cy){ return cx + ',' + cy; }

// data store for chunks
const chunks = new Map(); // key -> {cx,cy, color, createdAt}

// create/generate a chunk (cheap: single color per chunk)
function createChunk(cx, cy) {
  const v = seededValue(cx, cy);
  // map v to terrain color variants
  let color;
  if (v < 0.35) color = '#3b6f3b';      // grass
  else if (v < 0.55) color = '#7f5e2a'; // dirt
  else if (v < 0.75) color = '#8fb8ff'; // water-ish
  else color = '#bfbfbf';               // rock/snow
  const ch = {cx, cy, color, createdAt: Date.now()};
  chunks.set(key(cx,cy), ch);
  console.log('create chunk', key(cx,cy));
  return ch;
}

// remove chunk
function removeChunk(cx, cy) {
  if (chunks.delete(key(cx,cy))) {
    console.log('remove chunk', key(cx,cy));
  }
}

// ensure chunks within radius exist, remove others
function updateChunks(activeCx, activeCy, radius=RENDER_RADIUS) {
  // create needed
  for (let dx = -radius; dx <= radius; dx++) {
    for (let dy = -radius; dy <= radius; dy++) {
      const cx = activeCx + dx;
      const cy = activeCy + dy;
      const k = key(cx,cy);
      if (!chunks.has(k)) createChunk(cx,cy);
    }
  }
  // remove far chunks
  for (const k of Array.from(chunks.keys())) {
    const [cx, cy] = k.split(',').map(Number);
    const dist = Math.max(Math.abs(cx - activeCx), Math.abs(cy - activeCy));
    if (dist > radius) removeChunk(cx, cy);
  }
}

// ========== Player & Camera ==========
const player = {
  x: 0, // world px
  y: 0
};
const camera = {
  x: 0, y: 0,     // center world coords
  scale: 1
};

// controls
const keys = {};
addEventListener('keydown', e => {
  if (e.key === 'Tab') { e.preventDefault(); toggleOverview(); return; }
  keys[e.key.toLowerCase()] = true;
});
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// zoom keys
addEventListener('keydown', e => {
  if (e.key === '+' || e.key === '=') camera.scale *= 1.125;
  if (e.key === '-') camera.scale /= 1.125;
});

// compute active chunk from player pos
function activeChunkFor(player) {
  const cx = Math.floor(player.x / CHUNK_SIZE_PX);
  const cy = Math.floor(player.y / CHUNK_SIZE_PX);
  return {cx, cy};
}

// overview toggle: when on, camera tries to fit all rendered chunks into view
let overview = false;
function toggleOverview(){ overview = !overview; }

// fit camera to all rendered chunks
function computeOverviewTransform() {
  if (chunks.size === 0) return null;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const v of chunks.values()) {
    minX = Math.min(minX, v.cx * CHUNK_SIZE_PX);
    maxX = Math.max(maxX, v.cx * CHUNK_SIZE_PX + CHUNK_SIZE_PX);
    minY = Math.min(minY, v.cy * CHUNK_SIZE_PX);
    maxY = Math.max(maxY, v.cy * CHUNK_SIZE_PX + CHUNK_SIZE_PX);
  }
  const worldW = maxX - minX;
  const worldH = maxY - minY;
  // add tiny padding
  const pad = 40;
  const scaleX = (innerWidth - pad*2) / worldW;
  const scaleY = (innerHeight - pad*2) / worldH;
  const scale = Math.min(scaleX, scaleY, 1.0);
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  return {scale, centerX, centerY};
}

// ========== Main loop ==========
let last = performance.now();
function loop(now) {
  const dt = Math.min((now - last) / 1000, 0.05);
  last = now;

  // movement
  let vx = 0, vy = 0;
  if (keys['w'] || keys['arrowup']) vy -= 1;
  if (keys['s'] || keys['arrowdown']) vy += 1;
  if (keys['a'] || keys['arrowleft']) vx -= 1;
  if (keys['d'] || keys['arrowright']) vx += 1;
  if (vx !== 0 || vy !== 0) {
    const len = Math.hypot(vx, vy) || 1;
    vx = vx / len * PLAYER_SPEED;
    vy = vy / len * PLAYER_SPEED;
  }
  player.x += vx * dt;
  player.y += vy * dt;

  // update active chunk & chunk set
  const active = activeChunkFor(player);
  updateChunks(active.cx, active.cy, RENDER_RADIUS);

  // camera logic
  if (overview) {
    const t = computeOverviewTransform();
    if (t) {
      camera.scale = t.scale;
      camera.x = t.centerX;
      camera.y = t.centerY;
    } else {
      camera.x = player.x; camera.y = player.y;
    }
  } else {
    camera.x = player.x;
    camera.y = player.y;
  }

  // draw
  render(active);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ========== Rendering ==========
function worldToScreen(wx, wy) {
  const sx = (wx - camera.x) * camera.scale + innerWidth / 2;
  const sy = (wy - camera.y) * camera.scale + innerHeight / 2;
  return {sx, sy};
}
function screenToWorld(sx, sy) {
  const wx = (sx - innerWidth / 2) / camera.scale + camera.x;
  const wy = (sy - innerHeight / 2) / camera.scale + camera.y;
  return {wx, wy};
}

function render(active) {
  ctx.clearRect(0,0,innerWidth,innerHeight);

  // draw chunks
  for (const ch of chunks.values()) {
    const wx = ch.cx * CHUNK_SIZE_PX;
    const wy = ch.cy * CHUNK_SIZE_PX;
    const topLeft = worldToScreen(wx, wy);
    const size = CHUNK_SIZE_PX * camera.scale;
    // fill
    ctx.fillStyle = ch.color;
    ctx.fillRect(topLeft.sx, topLeft.sy, size, size);
  }

  // debug overlays: borders + coords
  for (const ch of chunks.values()) {
    const wx = ch.cx * CHUNK_SIZE_PX;
    const wy = ch.cy * CHUNK_SIZE_PX;
    const tl = worldToScreen(wx, wy);
    const size = CHUNK_SIZE_PX * camera.scale;

    // translucent fill to indicate "rendered"
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(tl.sx, tl.sy, size, size);

    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = Math.max(1, 1 * camera.scale);
    ctx.strokeRect(tl.sx + 0.5, tl.sy + 0.5, size - 1, size - 1);

    // coords
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = `${12 * Math.max(0.5, camera.scale)}px monospace`;
    ctx.fillText(`(${ch.cx},${ch.cy})`, tl.sx + 6, tl.sy + 16);
  }

  // highlight active chunk
  const actKey = key(active.cx, active.cy);
  if (chunks.has(actKey)) {
    const ch = chunks.get(actKey);
    const wx = ch.cx * CHUNK_SIZE_PX;
    const wy = ch.cy * CHUNK_SIZE_PX;
    const tl = worldToScreen(wx, wy);
    const size = CHUNK_SIZE_PX * camera.scale;
    ctx.strokeStyle = 'rgba(255,255,0,0.95)';
    ctx.lineWidth = 3;
    ctx.strokeRect(tl.sx+1, tl.sy+1, size-2, size-2);
  }

  // draw player
  const pScreen = worldToScreen(player.x - 8, player.y - 8);
  ctx.fillStyle = '#ff3377';
  ctx.beginPath();
  ctx.arc(pScreen.sx + 8*camera.scale, pScreen.sy + 8*camera.scale, 8 * Math.max(0.6, camera.scale), 0, Math.PI*2);
  ctx.fill();

  // HUD info
  const info = document.getElementById('info');
  const rendered = Array.from(chunks.keys()).join(' ');
  info.textContent = `Player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)}) | ActiveChunk: ${actKey} | Rendered: ${chunks.size} | Overview: ${overview ? 'ON' : 'OFF'}`;
}

// initial chunk population
const initialActive = activeChunkFor(player);
updateChunks(initialActive.cx, initialActive.cy, RENDER_RADIUS);

// center camera initially
camera.x = player.x; camera.y = player.y;

</script>
</body>
</html>
